---
title: Object Oriented Versus Functional
layout: default
comments: true
---

# Object Oriented Versus Functional

A few years ago the phrase first arrived to my awareness, "Object-Oriented Programming is dead in favor of Functional Programming". Over the years I have encountered a multitude of people making statements that aim in a similar direction of thought. A quick google search "Object-Oriented Programming is Dead" will reveal that this topic has quite a bit of discussion.

People make very rational arguments like, "Paradigms come and go, Object-Oriented is just one". This combined with a lot of hype around "Functional Programming" makes the statement of Object-Oriented Programming (OOP) dying in favor of something else, like Functional Programming (FP), seem plausible.

People who make the priorly quoted statements, or similar to them, are confusing two things. Those two things being, OOP as a philosophical concept of how to design the architecture of software and OOP components implemented in a language.

Java, C++, C#, Objective-C these are languages which have implemented in them components derived from the philosophies of OOP. They are not however the pure and authoritative representations of what OOP actually is. Rather, they are hybrid languages, they are hybrids of some OOP components and Procedural Programming. In the case of C# and Java, there are now components of FP being added to make them OOP, FP, Procedural hybrids.

A language with OOP components, or specific OOP components in a language may die and be replaced with something else. However OOP as a philosophical understanding of how to create the architecture of complex systems will not die. Even if you are in a purely FP language, OOP as a philosophy of architecture still applies and is the ideal perspective to take when figuring out architecture and organization.

OOP in it's most pure and original form, a philosophy of software architecture, is the result of taking the philosophical basis largely developed in the tradition of Hermeneutics and then applying it to the architecture of software and programming language design. To make code comprehensible to people, and allow code to be written in the way the human mind intuitively thinks. This perspective will always be relevant. The history and philosophy of OOP I believe is most thoroughly and properly covered in the book named 'Object Thinking' by David West. If you wish to understand better what OOP actually is, read 'Object Thinking'.

David West in recent years actually made the statement 'Object-Oriented Programming is dead. Long live of Object-Oriented Decomposition and Design'. I think he is recognizing that the term OOP has been fouled, and there is too much convolution and confusion about what it actually is. That people are confusing OOP as an architectural philosophy with OOP as language specific features. Thus rather than fighting to recover the word OOP, and convince most programmers they don't actually know what it is, he is simply making a new term, Object-Oriented Decomposition and Design (OODD). OODD referring to, without confusion, purely Object-Orientation as a philosophy on design of software architecture. This is perhaps a more intelligent stance to take, create a new term. One will use OODD to design the software, but then may implement it in a purely Functional language, or any language. So you end up with an Object-Oriented system implemented in a functional language.

Personally though, I would prefer people take the time to understand what OOP actually is, and we not just create a new term. We are after all programmers, we think, and rethink things, I would like to think we do not need PR tricks to reach accurate understanding. As such things may actually just create greater confusion over time.

OOP is not a programming language, OOP is not a feature of a programming language. Rather some programming languages have some components derived from the philosophy of OOP mixed into them to be a hybrid with other paradigms. First and foremost OOP is a philosophy on the architecture and organization of software. It is not at odds with FP.

FP, like OOP, is a term that tends to get used in different contexts. But when someone refers to FP I find they are referring primarily to three points, composability of functions, stateless system design and declarative syntax. None of these are at odds with Object Orientation.

The first point, in the subject of composability and architecture, [this study](http://se.ethz.ch/~meyer/publications/functional/meyer_functional_oo.pdf) doing a comprehensive analysis of Object-Oriented architecture and Functional architecture found that Object-Oriented architecture had the ability to entirely subsume the functional approach. Lack of composability of objects is not a fault of the paradigm, it is the fault of architect. I do not believe functional enables one to create superior system architecture.

The second point, stateless design can be done in any language. Stateless design is not unique to FP. However strict FP languages, due to certain tools, and coming with stateless libraries, do make it easier to create stateless systems. Stateless is the solution to parallelism, a point of huge importance in the advancement of computing. I have seen this cause a trend of thinking along the lines of, 'stateless is the future'. I disagree with this, stateless is the future, and also a current necessity in some contexts and problem domains, not all. Cluster computing, GPU computing, scalable server side, these are the type of domains where stateless is relevant. Desktops application, mobile applications, video games, these are not the domains where stateless design is unanimously relevant. Stateless gameplay mechanic code is a ridiculous notion, a player in a game world must store it's state, it's entire circumstance cannot be recalculated every access. If you are in a problem domain of needing to create a purely stateless system using a strict FP language may be smart. But one could still apply the philosophies of OO to the architecture of this system.

The third point, declarative syntax is the one domain where what is claimed to be FP is actually very much superior. But declarative syntax is not at odds with OO, declarative syntax is at odds with imperative syntax. Or rather, declarative programming is at odds with procedural programming. It is this point that I think most people come to the conclusion that what they suppose is FP will overcome something like C++. Because declarative syntax often enables cleaner implementation of a method. But it's not the OO of C++ that is being overcome by declarative syntax, it is rather the imperative syntax of C++, it is the procedural programming paradigm that is being overcome. I would completely agree that as we move into the future declarative syntax will override imperative syntax more and more, and we will see procedural programming erode away more and more. But OO is separate from that. I think an ideal future language will be OO and declarative. This is the type of view that Scala is taking, it enables OO architecture, but it's syntax is declarative. Microsoft is also going in a similar vein of thinking in adding F# to the CLR, enabling OO architecture, but declarative implementation through F#.

Thus in conclusion, OOP is not dead in favor of FP. I see this statement as a complete misunderstanding of the subject matter. I believe that OO, and thoroughly understanding all of it's philosophical and architectural concepts is still extremely important, and will always be.
